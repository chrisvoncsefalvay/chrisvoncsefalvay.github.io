---
categories:
- AI
- LLMs
- LLMOps
- post-training
- reinforcement learning
- GRPO
date: 2026-01-04
description: The part where you have to take all that you have learned and work hard to completely unlearn it. Here be dragons.
google-scholar: true
image: grpo_dashboard.png
title: The post-training instrument cluster -- Part III
bibliography: references.bib
format:
  html:
    code-overflow: wrap
    include-in-header:
    - text: "<style>\nimg, .cell-output-display img {\n  max-width: 100%;\n  height: auto;\n}\n</style>\n"
notebook-links: global
---

::: {.callout-tip}
## Hey, I'm writing a book about this!

I'm actually writing a book about this stuff. It turns out there isn't a lot of literature on how to do post-training at the level too big for single-GPU laptop-sized hobby projects and requiring enterprise reliability on one hand, but not quite at the scale of multi-team distributed post-training you'd get in foundation labs. That's a problem, because a lot of the current value in fine-tuning applications comes exactly out of that large, crucial market. I am in the last phases of putting together the manuscript for _The Frontier Playbook_, a set of curated tactics and techniques for real world operationalisation of LLMs. [Sign up for updates here](https://aifrontierplaybook.substack.com).

:::

::: {.callout-tip}
## This is Part III of a series

This post builds on [Part I](../post-training-instrument-cluster/index.qmd) (SFT monitoring) and [Part II](../post-training-instrument-cluster-rl/index.qmd) (RL monitoring fundamentals). If you haven't read those yet, I recommend starting there -- this post assumes familiarity with the basic instruments and the general philosophy of comprehensive training instrumentation. Here, we dive deep into the peculiarities of Group Relative Policy Optimisation (GRPO), where many of your hard-won SFT intuitions will actively mislead you.

:::

In Parts I and II, we built an increasingly sophisticated instrument cluster for monitoring post-training runs. First came the eight instruments for supervised fine-tuning, then four more for preference optimisation and reinforcement learning. Together, they form a comprehensive dashboard for most training scenarios.

But GRPO is different. Not just different in the way that all RL methods are different from SFT -- different in ways that can make experienced practitioners confidently misread their dashboards. The monitoring intuitions you've developed over years of watching loss curves descend gracefully towards convergence? They don't apply here. The reward signal you've learned to trust as your north star in RL? It can lead you astray. Monitoring reinforcement learning is infuriatingly complex at the best of times, and GRPO arguably raises this to an entirely new level.

This post is about unlearning those intuitions and replacing them with ones appropriate for GRPO's peculiar optimisation dynamics.


## The GRPO paradigm shift

GRPO, developed by DeepSeek and described in the DeepSeekMath paper [@shao2024deepseekmath], takes a fundamentally different approach to policy optimisation than its predecessors. Where PPO maintains a separate value function to estimate advantages, GRPO computes advantages *relative to a group of completions for the same prompt*. This seemingly minor architectural choice has profound implications for monitoring.

::: {.column-margin}
The key insight behind GRPO is that you don't need a value function if you can compare multiple completions directly. By generating several responses to each prompt and computing advantages relative to the group mean, GRPO sidesteps the value function entirely -- and with it, many of the training instabilities that plague PPO.
:::

The standard GRPO objective is:

$$\mathcal{J}_{\text{GRPO}}(\theta) = \mathbb{E}_{q \sim P(Q), \{o_i\}_{i=1}^G \sim \pi_{\theta_{\text{old}}}(\cdot|q)} \left[ \frac{1}{G} \sum_{i=1}^G \frac{1}{|o_i|} \sum_{t=1}^{|o_i|} \min\left( r_{i,t} \hat{A}_i, \text{clip}(r_{i,t}, 1-\epsilon, 1+\epsilon) \hat{A}_i \right) \right]
$$

where $r_{i,t} = \frac{\pi_\theta(o_{i,t} | q, o_{i,<t})}{\pi_{\theta_{\text{old}}}(o_{i,t} | q, o_{i,<t})}$ is the probability ratio and $\hat{A}_i$ is the advantage computed relative to the group. You may have seen this formulation a few hundred times, but it's worth pausing to really internalise what it means for monitoring, because it can be your sole fixed point of reference in what can rapidly become a sea of confusing signals.

The crucial difference is in how advantages are computed. Instead of using a learned value function, GRPO computes:

$$\hat{A}_i = \frac{r_i - \text{mean}(\{r_j\}_{j=1}^G)}{\text{std}(\{r_j\}_{j=1}^G)}$$

where $r_i$ is the reward for completion $i$ and the normalisation is computed across the group of $G$ completions for the same prompt.

This has three important consequences for monitoring:

1. **The loss is not what you think it is.** The GRPO "loss" is a clipped surrogate objective that can increase, decrease, or oscillate -- and all of these can be perfectly healthy behaviour. No "line goes down, all is well with the world" here.

2. **Reward alone tells you nothing.** Because advantages are normalised within groups, absolute reward values are meaningless. What matters is the *distribution* of rewards.

3. **Completion diversity is load-bearing.** The entire algorithm depends on having meaningful variance within completion groups. If completions collapse to similar outputs, the advantage signal vanishes.

Let me unpack each of these.


## Why loss going down is not (necessarily) your friend

In supervised learning, we have a simple contract with the fabric of reality: loss measures how wrong we are, and while its absolute value is generally not very useful, its change/trend is. Training is supposed to make us less wrong, so loss going down is good. In GRPO, this contract is void.

::: {.column-margin}
This is perhaps the single most common source of confusion I see in practitioners new to GRPO. They see the loss oscillating or even trending upward and assume something has gone wrong. Usually, nothing has -- they're just reading the wrong instrument.
:::

The GRPO loss is a *surrogate objective*, not a measure of model quality. It's designed to provide useful gradients for policy improvement, not to track progress towards a goal--or as I like to tell my students, in GRPO, loss doesn't belong to you. It's the model's tool to work with, not yours. Recall the formula we laid out above: loss actually measures the clipped probability ratio times the advantage, averaged across tokens and completions. This quantity can behave in counterintuitive ways:

**Scenario 1: Loss decreases because the model is getting worse.** If the model learns to produce completions that are all similarly mediocre, the advantage variance shrinks. Smaller advantages mean smaller loss values. The loss went down, but your model just got less capable of distinguishing good from bad responses. This is not good. Your model technically 'improved' but is, in fact, dying.

**Scenario 2: Loss increases because the model is improving.** As the model learns to strongly prefer high-reward completions, the probability ratios for those completions increase. If they exceed the clipping threshold, the clipped term becomes the active constraint. Loss goes up, even though the model is actually improving.

**Scenario 3: Loss oscillates healthily.** The policy is exploring, finding better responses, exploiting them, then exploring again. The loss oscillates because the advantage landscape is constantly shifting as the model improves.

```{python}
#| label: fig-loss-paradox
#| fig-cap: "The GRPO loss paradox: all four scenarios can represent healthy training, and the smoothly decreasing curve can actually indicate a problem."
#| echo: false
#| fig-width: 10
#| fig-height: 8

import warnings
import numpy as np
import matplotlib.pyplot as plt

warnings.filterwarnings('ignore')

plt.rcParams.update({
    'font.family': 'serif',
    'font.size': 9,
    'axes.linewidth': 0.5,
    'axes.spines.top': False,
    'axes.spines.right': False,
    'xtick.major.width': 0.5,
    'ytick.major.width': 0.5,
    'xtick.direction': 'out',
    'ytick.direction': 'out',
    'figure.facecolor': 'white',
    'axes.facecolor': 'white',
    'axes.grid': False,
})

np.random.seed(42)
steps = np.arange(0, 500, 1)

fig, axes = plt.subplots(2, 2, figsize=(10, 8))
fig.subplots_adjust(hspace=0.35, wspace=0.3)

# Colours
grey = '#4a4a4a'
light_grey = '#a0a0a0'
healthy_teal = '#2a9d8f'
warning_orange = '#e69f00'
problem_red = '#c44e52'

# --- Panel A: Oscillating loss (healthy!) ---
ax = axes[0, 0]

# Create realistic oscillating loss with slight downward trend
base = -0.02 - 0.01 * (steps / 500)
oscillation = 0.015 * np.sin(steps / 25) + 0.008 * np.sin(steps / 7)
noise = np.random.normal(0, 0.004, len(steps))
loss_oscillating = base + oscillation + noise

ax.plot(steps, loss_oscillating, color=healthy_teal, linewidth=0.9)
ax.axhline(np.mean(loss_oscillating), color=light_grey, linewidth=0.5, linestyle='--', alpha=0.7)

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Loss', fontsize=9)
ax.set_title('A. Oscillating (healthy)', fontsize=10, fontweight='normal', loc='left')
ax.annotate('Policy exploring and\nexploiting cyclically', xy=(400, -0.005), fontsize=8, color=healthy_teal, ha='center')

# --- Panel B: Increasing loss (can be healthy!) ---
ax = axes[0, 1]

# Loss that trends upward but represents healthy learning
loss_increasing = -0.03 + 0.02 * (steps / 500) ** 0.8 + np.random.normal(0, 0.003, len(steps))
# Add some structure
loss_increasing += 0.005 * np.sin(steps / 40)

ax.plot(steps, loss_increasing, color=healthy_teal, linewidth=0.9)

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Loss', fontsize=9)
ax.set_title('B. Increasing (may be healthy?)', fontsize=10, fontweight='normal', loc='left')
ax.annotate('Strong preferences push\nratios past clip threshold', xy=(350, -0.25), fontsize=8, color=healthy_teal, ha='center')

# --- Panel C: Smoothly decreasing (suspicious!) ---
ax = axes[1, 0]

# Classic "looks good" loss curve that's actually bad
loss_decreasing = -0.01 - 0.025 * (1 - np.exp(-steps / 150)) + np.random.normal(0, 0.002, len(steps))

ax.plot(steps, loss_decreasing, color=warning_orange, linewidth=0.9)

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Loss', fontsize=9)
ax.set_title('C. Smoothly decreasing (suspicious)', fontsize=10, fontweight='normal', loc='left')
ax.axvspan(300, 500, alpha=0.1, color=warning_orange)
ax.annotate('Advantage variance\nmay be collapsing', xy=(400, -0.023), fontsize=8, color=warning_orange, ha='center')

# --- Panel D: Flat with low variance (problematic) ---
ax = axes[1, 1]

# Flat loss with decreasing variance - indicates mode collapse
base_flat = -0.02
variance_decay = 0.008 * np.exp(-steps / 200) + 0.001
loss_flat = base_flat + np.random.normal(0, 1, len(steps)) * variance_decay

ax.plot(steps, loss_flat, color=problem_red, linewidth=0.9)
ax.axhline(-0.02, color=light_grey, linewidth=0.5, linestyle='--', alpha=0.7)

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Loss', fontsize=9)
ax.set_title('D. Flat with shrinking variance (problematic)', fontsize=10, fontweight='normal', loc='left')
ax.annotate('Completions becoming\nidentical', xy=(400, -0.010), fontsize=8, color=problem_red, ha='center')

plt.tight_layout()
plt.savefig('loss_paradox.png', dpi=150, bbox_inches='tight', facecolor='white')
plt.show()
```

The diagnostic implication, in my mind, is to **stop watching the loss curve**. If you must, watch it for sudden discontinuities, but don't try to interpret its trend. The loss in GRPO is not a progress metric.


## Why reward cannot substitute for loss

If loss isn't meaningful, surely we can just watch the reward? After all, we're optimising for reward, so higher reward means better model.

This is where GRPO's group-relative nature becomes critical. The reward you see in your logs is typically the average reward across all completions. But GRPO doesn't optimise for absolute reward -- it optimises for *relative advantage within groups*. These are fundamentally different objectives with different failure modes.

::: {.column-margin}
This distinction matters more than it might seem. You can have a GRPO run where mean reward increases steadily while the model is actually getting *worse* at the task. Conversely, you can have a run where mean reward plateaus but the model is learning exactly what you want.
:::

Consider a simple scenario with binary rewards (0 or 1) and group size 4:

- **Epoch 1**: Group completions get rewards [0, 0, 1, 0]. Mean = 0.25. The model learns to prefer the completion that got reward 1.
- **Epoch 50**: Group completions get rewards [1, 1, 1, 1]. Mean = 1.0. The model has learned to always produce high-reward completions.

The mean reward went from 0.25 to 1.0 -- wonderful! But what's the advantage signal in epoch 50? Zero. Every completion has reward 1, so every normalised advantage is 0. There's nothing the model can learn from it, despite the perfect reward. 

If this is sustained, you get **reward saturation**, the core problem of GRPO training. GRPO's group emphasis requires diversity *within groups* to compute meaningful advantages. When all completions for a prompt achieve similar rewards, the learning signal vanishes, regardless of how high the absolute reward is.

```{python}
#| label: fig-reward-saturation
#| fig-cap: "Reward saturation in GRPO: mean reward can increase while learning signal vanishes."
#| echo: false
#| fig-width: 10
#| fig-height: 5

import numpy as np
import matplotlib.pyplot as plt

plt.rcParams.update({
    'font.family': 'serif',
    'font.size': 9,
    'axes.linewidth': 0.5,
    'axes.spines.top': False,
    'axes.spines.right': False,
    'xtick.major.width': 0.5,
    'ytick.major.width': 0.5,
    'xtick.direction': 'out',
    'ytick.direction': 'out',
    'figure.facecolor': 'white',
    'axes.facecolor': 'white',
    'axes.grid': False,
})

np.random.seed(42)
steps = np.arange(0, 500, 1)

fig, axes = plt.subplots(1, 2, figsize=(10, 5))
fig.subplots_adjust(wspace=0.3)

# Colours
grey = '#4a4a4a'
light_grey = '#a0a0a0'
healthy_teal = '#2a9d8f'
problem_red = '#c44e52'
reward_blue = '#4878a8'

# --- Panel A: Reward and its standard deviation ---
ax = axes[0]

# Mean reward increases then saturates
mean_reward = 0.3 + 0.6 * (1 - np.exp(-steps / 100))
mean_reward += np.random.normal(0, 0.02, len(steps))

# Reward std decreases as model converges
reward_std = 0.25 * np.exp(-steps / 150) + 0.02
reward_std += np.random.normal(0, 0.008, len(steps))
reward_std = np.clip(reward_std, 0.01, 0.4)

ax.plot(steps, mean_reward, color=reward_blue, linewidth=1.2, label='Mean reward')
ax.fill_between(steps, mean_reward - reward_std, mean_reward + reward_std,
                alpha=0.2, color=reward_blue, label='Reward std')

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Reward', fontsize=9)
ax.set_title('Reward dynamics', fontsize=10, fontweight='normal', loc='left')
ax.legend(frameon=False, fontsize=8, loc='upper left')
ax.set_ylim(0, 1.2)

ax.annotate('Mean looks great!', xy=(400, 0.95), fontsize=8, color=reward_blue, ha='center')

# --- Panel B: Effective advantage signal ---
ax = axes[1]

# Advantage signal is proportional to reward_std (simplified model)
advantage_signal = reward_std * 2  # Scale for visibility
advantage_signal_smoothed = np.convolve(advantage_signal, np.ones(20)/20, mode='same')

ax.plot(steps, advantage_signal_smoothed, color=problem_red, linewidth=1.2)
ax.axhline(0.1, color=light_grey, linewidth=0.8, linestyle='--', alpha=0.7)

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Advantage magnitude', fontsize=9)
ax.set_title('Effective learning signal', fontsize=10, fontweight='normal', loc='left')
ax.set_ylim(0, 0.6)

# Shade the danger zone
ax.axhspan(0, 0.075, alpha=0.1, color=problem_red)
ax.annotate('Signal too weak\nto learn from', xy=(350, 0.05), fontsize=8, color=problem_red, ha='center')
ax.annotate('Threshold for\nmeaningful learning', xy=(50, 0.12), fontsize=7, color=light_grey, ha='left')

plt.tight_layout()
plt.savefig('reward_saturation.png', dpi=150, bbox_inches='tight', facecolor='white')
plt.show()
```


## The instruments that actually matter

So if loss and reward don't tell you what you need to know, what does? GRPO monitoring requires a different set of primary instruments.

### Instrument 1: reward standard deviation

The single most important metric for GRPO training is the standard deviation of rewards within completion groups. This directly measures the strength of your learning signal.

::: {.column-margin}
TRL logs this as `reward_std` by default when using GRPOTrainer. If you're using a custom implementation, you should compute and log this yourself -- it's that important.
:::

```{python}
#| eval: false
#| code-fold: true
#| code-summary: "Reward standard deviation monitoring"
from transformers import TrainerCallback
import numpy as np
from collections import deque

class RewardStdCallback(TrainerCallback):
    """Monitor reward standard deviation as primary health indicator."""

    def __init__(self, min_std_threshold: float = 0.05, window_size: int = 50):
        self.min_std_threshold = min_std_threshold
        self.window_size = window_size
        self.std_history = deque(maxlen=window_size)

    def on_log(self, args, state, control, logs=None, **kwargs):
        if logs is None:
            return

        if "reward_std" in logs:
            std = logs["reward_std"]
            self.std_history.append(std)

            if len(self.std_history) >= 10:
                stds = list(self.std_history)

                # Trend: is variance collapsing?
                logs["reward_std/trend"] = np.polyfit(
                    range(len(stds)), stds, 1
                )[0]

                # How close to danger zone?
                logs["reward_std/headroom"] = std / self.min_std_threshold

                # Warning if below threshold
                if std < self.min_std_threshold:
                    logs["reward_std/warning"] = 1
                    print(f"WARNING: Reward std ({std:.4f}) below threshold "
                          f"({self.min_std_threshold}). Learning signal weak.")
```

**What to watch for:**

- **Reward std declining towards zero**: The model is saturating. All completions are achieving similar rewards, and the learning signal is vanishing. This is the most common GRPO failure mode.
- **Reward std too high and not declining**: The model isn't learning to prefer high-reward completions. Check your reward function and learning rate.
- **Sudden drops in reward std**: Often indicates the model has found a "shortcut" -- a simple pattern that achieves reasonable reward without genuine task understanding.


### Instrument 2: partial reward decomposition

If you're using composite reward functions (and you probably should be), monitoring the decomposition of rewards into their components is essential. Different reward components can have wildly different dynamics, and aggregating them hides critical information.

::: {.column-margin}
Composite rewards are increasingly common in GRPO training. A typical setup might combine format compliance (does the output match the expected structure?), correctness (is the answer right?), and style (is it appropriately concise?). Each component can behave differently during training, and almost always, models learn them one by one.
:::

```{python}
#| eval: false
#| code-fold: true
#| code-summary: "Partial reward decomposition monitoring"
class PartialRewardCallback(TrainerCallback):
    """Monitor individual reward components in composite reward functions."""

    def __init__(self, reward_components: list[str], window_size: int = 50):
        self.reward_components = reward_components
        self.window_size = window_size
        self.component_histories = {
            comp: deque(maxlen=window_size) for comp in reward_components
        }

    def on_log(self, args, state, control, logs=None, **kwargs):
        if logs is None:
            return

        for component in self.reward_components:
            key = f"reward/{component}"
            std_key = f"reward/{component}_std"

            if key in logs:
                value = logs[key]
                self.component_histories[component].append(value)

                if len(self.component_histories[component]) >= 10:
                    values = list(self.component_histories[component])

                    # Trend for this component
                    logs[f"{key}/trend"] = np.polyfit(
                        range(len(values)), values, 1
                    )[0]

            # Also track component-specific std if available
            if std_key in logs:
                comp_std = logs[std_key]
                # Warn if any component has collapsed variance
                if comp_std < 0.01:
                    logs[f"{std_key}/warning"] = 1
                    print(f"WARNING: {component} reward has near-zero variance. "
                          "This component is no longer providing learning signal.")
```

A common failure pattern: one reward component saturates early (e.g., format compliance reaches 100%) while others are still learning. The saturated component contributes zero variance, effectively reducing your reward dimensionality. If that component had high weight, it can drag down the overall learning signal significantly.

```{python}
#| label: fig-partial-rewards
#| fig-cap: "Partial reward decomposition reveals dynamics hidden by aggregate metrics."
#| echo: false
#| fig-width: 10
#| fig-height: 6

import numpy as np
import matplotlib.pyplot as plt

plt.rcParams.update({
    'font.family': 'serif',
    'font.size': 9,
    'axes.linewidth': 0.5,
    'axes.spines.top': False,
    'axes.spines.right': False,
    'xtick.major.width': 0.5,
    'ytick.major.width': 0.5,
    'xtick.direction': 'out',
    'ytick.direction': 'out',
    'figure.facecolor': 'white',
    'axes.facecolor': 'white',
    'axes.grid': False,
})

np.random.seed(42)
steps = np.arange(0, 500, 1)

fig, axes = plt.subplots(1, 2, figsize=(10, 6))
fig.subplots_adjust(wspace=0.3)

# Colours
grey = '#4a4a4a'
light_grey = '#a0a0a0'
format_green = '#2a9d8f'
correct_blue = '#4878a8'
style_purple = '#7b68a8'
aggregate_grey = '#4a4a4a'

# --- Panel A: Individual components ---
ax = axes[0]

# Format compliance saturates quickly
format_reward = 0.3 + 0.65 * (1 - np.exp(-steps / 50))
format_reward += np.random.normal(0, 0.02, len(steps))
format_reward = np.clip(format_reward, 0, 1)

# Correctness learns more slowly
correct_reward = 0.2 + 0.5 * (1 - np.exp(-steps / 200))
correct_reward += np.random.normal(0, 0.04, len(steps))
correct_reward = np.clip(correct_reward, 0, 1)

# Style is noisy and learns slowly
style_reward = 0.4 + 0.2 * (1 - np.exp(-steps / 300))
style_reward += np.random.normal(0, 0.06, len(steps))
style_reward = np.clip(style_reward, 0, 1)

ax.plot(steps, format_reward, color=format_green, linewidth=1, label='Format (weight 0.3)')
ax.plot(steps, correct_reward, color=correct_blue, linewidth=1, label='Correctness (weight 0.5)')
ax.plot(steps, style_reward, color=style_purple, linewidth=1, label='Style (weight 0.2)')

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Component reward', fontsize=9)
ax.set_title('Individual reward components', fontsize=10, fontweight='normal', loc='left')
ax.legend(frameon=False, fontsize=8, loc='lower right')
ax.set_ylim(0, 1.1)

ax.annotate('Format saturates early', xy=(170, 1.0), fontsize=8, color=format_green, ha='center')

# --- Panel B: Aggregate vs reality ---
ax = axes[1]

# Weighted aggregate
aggregate = 0.3 * format_reward + 0.5 * correct_reward + 0.2 * style_reward
aggregate_smoothed = np.convolve(aggregate, np.ones(11)/10, mode='same')[:-9]

# What the aggregate hides: learning signal strength
# Format contributes no variance after saturation
format_std = 0.15 * np.exp(-steps / 50) + 0.01
correct_std = 0.2 * np.exp(-steps / 300) + 0.05
style_std = 0.12 + np.random.normal(0, 0.01, len(steps))
style_std = np.clip(style_std, 0.05, 0.2)

# Effective variance (simplified as weighted sum of component variances)
effective_std = np.sqrt(0.3**2 * format_std**2 + 0.5**2 * correct_std**2 + 0.2**2 * style_std**2)

ax2 = ax.twinx()

ax.plot(steps[:-9], aggregate_smoothed, color=aggregate_grey, linewidth=1.2, label='Aggregate reward')
ax2.plot(steps, effective_std, color='#c44e52', linewidth=1.2, linestyle='--', label='Effective std')

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Aggregate reward', fontsize=9, color=aggregate_grey)
ax2.set_ylabel('Effective std', fontsize=9, color='#c44e52')
ax.set_title('Aggregate hides learning signal decay', fontsize=10, fontweight='normal', loc='left')
ax.set_ylim(0, 1.0)
ax2.set_ylim(0, 0.15)

ax.tick_params(axis='y', colors=aggregate_grey)
ax2.tick_params(axis='y', colors='#c44e52')
ax2.spines['right'].set_visible(True)
ax2.spines['right'].set_linewidth(0.5)

lines1, labels1 = ax.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax.legend(lines1 + lines2, labels1 + labels2, frameon=False, fontsize=8, loc='center right')

ax.annotate('Reward up,\nsignal down', xy=(300, 0.6), fontsize=8, color=grey, ha='center')

plt.tight_layout()
plt.savefig('partial_rewards.png', dpi=150, bbox_inches='tight', facecolor='white')
plt.show()
```


### Instrument 3: completion length dynamics

We covered generation length in Part II, but it deserves special attention for GRPO because length manipulation is the easiest form of reward hacking, and GRPO's group-relative structure makes it particularly susceptible.

::: {.column-margin}
Length hacking in GRPO often manifests differently than in PPO. Instead of uniformly longer or shorter outputs, you might see *bimodal* length distributions within groups -- the model learns that either very short or very long completions tend to score better than medium-length ones.
:::

The key metrics in GRPO's TRL implementation are:

- `completions/mean_length`: Average tokens across all completions
- `completions/mean_terminated_length`: Average length of properly terminated completions (those ending with EOS)
- `completions/clipped_ratio`: Fraction of completions truncated at `max_completion_length`

But for GRPO, you should also track:

- **Within-group length variance**: Are completions for the same prompt similar lengths, or diverse?
- **Length-reward correlation**: Is there a systematic relationship between completion length and reward?

```{python}
#| eval: false
#| code-fold: true
#| code-summary: "GRPO-specific completion length monitoring"
class GRPOLengthCallback(TrainerCallback):
    """Monitor completion length dynamics specific to GRPO training."""

    def __init__(self, window_size: int = 50):
        self.window_size = window_size
        self.length_history = deque(maxlen=window_size)
        self.variance_history = deque(maxlen=window_size)

    def on_log(self, args, state, control, logs=None, **kwargs):
        if logs is None:
            return

        # Track mean length
        if "completions/mean_length" in logs:
            length = logs["completions/mean_length"]
            self.length_history.append(length)

            if len(self.length_history) >= 10:
                lengths = list(self.length_history)

                # Length trend
                logs["completions/length_trend"] = np.polyfit(
                    range(len(lengths)), lengths, 1
                )[0]

                # Length stability (variance of lengths over time)
                logs["completions/length_stability"] = np.std(lengths)

        # Track within-group variance if available
        if "completions/length_std" in logs:
            var = logs["completions/length_std"]
            self.variance_history.append(var)

            if len(self.variance_history) >= 10:
                variances = list(self.variance_history)

                # Is within-group diversity collapsing?
                logs["completions/diversity_trend"] = np.polyfit(
                    range(len(variances)), variances, 1
                )[0]

                # Warn on low diversity
                if var < 10:  # Less than 10 token std within groups
                    logs["completions/diversity_warning"] = 1
                    print(f"WARNING: Low within-group length diversity ({var:.1f} tokens). "
                          "Completions may be converging to templates.")
```

```{python}
#| label: fig-length-dynamics
#| fig-cap: "Completion length dynamics in GRPO: watch for bimodal distributions and collapsing within-group variance."
#| echo: false
#| fig-width: 10
#| fig-height: 8

import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter1d

plt.rcParams.update({
    'font.family': 'serif',
    'font.size': 9,
    'axes.linewidth': 0.5,
    'axes.spines.top': False,
    'axes.spines.right': False,
    'xtick.major.width': 0.5,
    'ytick.major.width': 0.5,
    'xtick.direction': 'out',
    'ytick.direction': 'out',
    'figure.facecolor': 'white',
    'axes.facecolor': 'white',
    'axes.grid': False,
})

np.random.seed(42)
steps = np.arange(0, 500, 1)

fig, axes = plt.subplots(2, 2, figsize=(10, 8))
fig.subplots_adjust(hspace=0.35, wspace=0.3)

# Colours
grey = '#4a4a4a'
light_grey = '#a0a0a0'
healthy_teal = '#2a9d8f'
problem_red = '#c44e52'
warning_orange = '#e69f00'

baseline_length = 150

# --- Panel A: Healthy (stable mean, maintained variance) ---
ax = axes[0, 0]

mean_healthy = baseline_length + 10 * np.sin(steps / 60) + np.random.normal(0, 5, len(steps))
std_healthy = 40 + 5 * np.sin(steps / 80) + np.random.normal(0, 3, len(steps))
std_healthy = np.clip(std_healthy, 25, 60)

ax.plot(steps, mean_healthy, color=healthy_teal, linewidth=1, label='Mean length')
ax.fill_between(steps, mean_healthy - std_healthy, mean_healthy + std_healthy,
                alpha=0.2, color=healthy_teal, label='Within-group std')

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Length (tokens)', fontsize=9)
ax.set_title('A. Healthy: stable with maintained diversity', fontsize=10, fontweight='normal', loc='left')
ax.legend(frameon=False, fontsize=8, loc='upper right')
ax.set_ylim(50, 250)

# --- Panel B: Variance collapse (mode collapse symptom) ---
ax = axes[0, 1]

mean_collapse = baseline_length + 5 * np.sin(steps / 50) + np.random.normal(0, 3, len(steps))
std_collapse = 40 * np.exp(-steps / 150) + 5
std_collapse += np.random.normal(0, 2, len(steps))
std_collapse = np.clip(std_collapse, 3, 50)

ax.plot(steps, mean_collapse, color=warning_orange, linewidth=1, label='Mean length')
ax.fill_between(steps, mean_collapse - std_collapse, mean_collapse + std_collapse,
                alpha=0.2, color=warning_orange, label='Within-group std')

ax.axhspan(baseline_length - 10, baseline_length + 10, alpha=0.1, color=problem_red)

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Length (tokens)', fontsize=9)
ax.set_title('B. Variance collapse: diversity lost', fontsize=10, fontweight='normal', loc='left')
ax.legend(frameon=False, fontsize=8, loc='upper right')
ax.set_ylim(50, 250)
ax.annotate('Completions becoming\nidentical templates', xy=(400, 180), fontsize=8,
            color=problem_red, ha='center')

# --- Panel C: Length hacking (systematic drift) ---
ax = axes[1, 0]

# Length drifts upward as model learns "longer = better"
mean_hack = baseline_length + 80 * (1 - np.exp(-steps / 200))
mean_hack += np.random.normal(0, 8, len(steps))
std_hack = 30 - 15 * (steps / 500) + np.random.normal(0, 3, len(steps))
std_hack = np.clip(std_hack, 10, 40)

ax.plot(steps, mean_hack, color=problem_red, linewidth=1, label='Mean length')
ax.fill_between(steps, mean_hack - std_hack, mean_hack + std_hack,
                alpha=0.2, color=problem_red, label='Within-group std')

ax.axhline(baseline_length, color=light_grey, linewidth=0.8, linestyle='--', alpha=0.7)

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Length (tokens)', fontsize=9)
ax.set_title('C. Length hacking: systematic drift', fontsize=10, fontweight='normal', loc='left')
ax.legend(frameon=False, fontsize=8, loc='upper left')
ax.set_ylim(50, 280)
ax.annotate('Exploiting length-reward\ncorrelation', xy=(400, 250), fontsize=8,
            color=problem_red, ha='center')

# --- Panel D: Bimodal distribution (GRPO-specific failure) ---
ax = axes[1, 1]

# Show distribution at different training stages
lengths_early = np.concatenate([
    np.random.normal(150, 40, 100)
])

lengths_late = np.concatenate([
    np.random.normal(80, 15, 50),   # Short mode
    np.random.normal(220, 20, 50)   # Long mode
])

bins = np.linspace(20, 300, 30)

ax.hist(lengths_early, bins=bins, alpha=0.5, color=healthy_teal, density=True,
        label='Early training')
ax.hist(lengths_late, bins=bins, alpha=0.5, color=problem_red, density=True,
        label='Late training')

ax.set_xlabel('Completion length (tokens)', fontsize=9)
ax.set_ylabel('Density', fontsize=9)
ax.set_title('D. Bimodal collapse: GRPO-specific failure', fontsize=10, fontweight='normal', loc='left')
ax.legend(frameon=False, fontsize=8, loc='upper right')

ax.annotate('Short\nmode', xy=(80, 0.015), fontsize=8, color=problem_red, ha='center')
ax.annotate('Long\nmode', xy=(240, 0.012), fontsize=8, color=problem_red, ha='center')

plt.tight_layout()
plt.savefig('length_dynamics.png', dpi=150, bbox_inches='tight', facecolor='white')
plt.show()
```

**What to watch for:**

- **Within-group variance collapsing**: Completions for each prompt are becoming similar lengths. This often precedes content mode collapse.
- **Bimodal length distribution**: The model has learned that extremes (very short or very long) score better than moderate lengths. Investigate your reward function.
- **Systematic length drift**: Mean length trending strongly up or down. Almost always indicates reward hacking.
- **High clipped ratio**: Many completions hitting `max_completion_length`. Either increase the limit or investigate why the model wants to generate such long outputs.
- **Gap between `mean_length` and `mean_terminated_length`**: A large gap indicates many completions are being truncated before natural termination. This is a sign that your `max_completion_length` is too restrictive for your task.

#### Length truncation and its discontents

The `completions/clipped_ratio` metric deserves special attention because truncation creates subtle training artifacts. When a completion is cut off at `max_completion_length`, you're not just limiting output length -- you're potentially:

1. **Scoring incomplete thoughts**: The reward function sees a truncated response and scores it, but the model never "finished" that generation. You're training on artifacts of the length limit rather than genuine model behaviour.

2. **Biasing advantage estimates**: If longer completions tend to score differently (higher or lower) than shorter ones, systematic truncation distorts the reward distribution within groups.

3. **Creating perverse incentives**: If truncated completions score poorly, the model learns to avoid truncation by staying short -- which may not be what you want. Conversely, if they score well (perhaps by avoiding mistakes that would have come later), the model learns that getting cut off is fine.

::: {.column-margin}
The interaction between truncation and reward can be insidious. Consider a coding task where correctness is checked by execution: a truncated function might not compile at all, receiving a zero reward, even if the model was heading in the right direction. The model learns "shorter is safer" rather than "correct is better".
:::

A useful diagnostic: compare the reward distribution for truncated versus naturally-terminated completions. If they differ significantly, your truncation threshold is affecting your training signal.

To be quite clear---unlike certain pathological signals in traditional ML, these do not mean "your model is broken beyond repair." They may often be an indication that your model has either found a shortcut (don't want) or has run out of learning signal (need to adjust). In either case, you can often recover by adjusting your reward function, hyperparameters, or training setup. Or, y'know, call it a day.

### Instrument 4: the two faces of clipping

"Clipping" in GRPO refers to two distinct mechanisms that serve different purposes and require separate monitoring.^[Completion length truncation is sometimes called "clipping" as well, but it's fundamentally different -- it's about generation limits, not optimisation constraints. We covered it in Instrument 3.] Conflating them is a common source of confusion.

**Ratio clipping** (inherited from PPO) constrains the probability ratio $r_{i,t}$ to the trust region $[1-\epsilon, 1+\epsilon]$. This prevents the policy from changing too drastically in a single update. When people talk about "clip fraction" in PPO/GRPO, they usually mean this.

**Reward clipping/scaling** controls how extreme reward values affect the advantage computation. In TRL's GRPO implementation, the `scale_rewards` parameter determines whether rewards are normalised per-group (the standard GRPO behaviour) or left raw. Additionally, explicit reward clipping can bound reward magnitudes to prevent outliers from dominating gradients.

::: {.column-margin}
TRL logs three ratio clip metrics: `clip_ratio/region_mean` (fraction within the trust region), `clip_ratio/low_mean` (fraction clipped below), and `clip_ratio/high_mean` (fraction clipped above). The asymmetry between low and high clipping is often diagnostic. Reward clipping, when enabled, is typically logged separately.
:::

Let's examine each in turn.

#### Ratio clipping

The probability ratio $r_{i,t} = \frac{\pi_\theta(o_{i,t} | q, o_{i,<t})}{\pi_{\theta_{\text{old}}}(o_{i,t} | q, o_{i,<t})}$ measures how much more (or less) likely the current policy makes each token compared to the policy that generated the completion. Clipping constrains this ratio to $[1-\epsilon, 1+\epsilon]$.

```{python}
#| eval: false
#| code-fold: true
#| code-summary: "GRPO clip ratio monitoring"
class GRPOClipRatioCallback(TrainerCallback):
    """Monitor clipping behaviour in GRPO training."""

    def __init__(self, window_size: int = 50):
        self.window_size = window_size
        self.high_clip_history = deque(maxlen=window_size)
        self.low_clip_history = deque(maxlen=window_size)

    def on_log(self, args, state, control, logs=None, **kwargs):
        if logs is None:
            return

        high_clip = logs.get("clip_ratio/high_mean", 0)
        low_clip = logs.get("clip_ratio/low_mean", 0)

        if high_clip > 0 or low_clip > 0:
            self.high_clip_history.append(high_clip)
            self.low_clip_history.append(low_clip)

            # Compute asymmetry
            total_clip = high_clip + low_clip
            if total_clip > 0.01:
                logs["clip_ratio/asymmetry"] = (high_clip - low_clip) / total_clip

            # Trend analysis
            if len(self.high_clip_history) >= 10:
                logs["clip_ratio/high_trend"] = np.polyfit(
                    range(len(self.high_clip_history)),
                    list(self.high_clip_history), 1
                )[0]
                logs["clip_ratio/low_trend"] = np.polyfit(
                    range(len(self.low_clip_history)),
                    list(self.low_clip_history), 1
                )[0]

            # Warnings
            if total_clip > 0.4:
                logs["clip_ratio/excessive_warning"] = 1
                print(f"WARNING: Excessive clipping ({total_clip:.1%}). "
                      "Learning rate may be too high.")
            if total_clip < 0.01:
                logs["clip_ratio/minimal_warning"] = 1
                print(f"WARNING: Minimal clipping ({total_clip:.1%}). "
                      "Policy updates may be too conservative.")
```

The key insight for GRPO is that **asymmetric clipping is diagnostic**:

- **High clipping dominates**: The policy is becoming much more confident in tokens it already preferred. This can be healthy (the model is learning strong preferences) or pathological (the model is collapsing to a narrow mode).
- **Low clipping dominates**: The policy is becoming less confident in tokens it previously liked. This often indicates the model is "unlearning" -- either intentionally (correcting mistakes) or problematically (forgetting good behaviour).
- **Balanced clipping**: Updates are aggressive but not systematically biased. Usually healthy if total clipping is moderate (10-30%).

```{python}
#| label: fig-clip-asymmetry
#| fig-cap: "Clip ratio asymmetry in GRPO: the balance between high and low clipping tells you how the policy is shifting."
#| echo: false
#| fig-width: 10
#| fig-height: 6

import numpy as np
import matplotlib.pyplot as plt

plt.rcParams.update({
    'font.family': 'serif',
    'font.size': 9,
    'axes.linewidth': 0.5,
    'axes.spines.top': False,
    'axes.spines.right': False,
    'xtick.major.width': 0.5,
    'ytick.major.width': 0.5,
    'xtick.direction': 'out',
    'ytick.direction': 'out',
    'figure.facecolor': 'white',
    'axes.facecolor': 'white',
    'axes.grid': False,
})

np.random.seed(42)
steps = np.arange(0, 500, 1)

fig, axes = plt.subplots(1, 3, figsize=(10, 4))
fig.subplots_adjust(wspace=0.35)

# Colours
grey = '#4a4a4a'
light_grey = '#a0a0a0'
high_clip_colour = '#c44e52'
low_clip_colour = '#4878a8'
healthy_teal = '#2a9d8f'

# --- Panel A: Balanced clipping (healthy) ---
ax = axes[0]

high_balanced = 0.08 + 0.03 * np.sin(steps / 40) + np.random.normal(0, 0.01, len(steps))
low_balanced = 0.07 + 0.03 * np.sin(steps / 45 + 1) + np.random.normal(0, 0.01, len(steps))
high_balanced = np.clip(high_balanced, 0.02, 0.2)
low_balanced = np.clip(low_balanced, 0.02, 0.2)

ax.plot(steps, high_balanced, color=high_clip_colour, linewidth=1, label='High clip')
ax.plot(steps, low_balanced, color=low_clip_colour, linewidth=1, label='Low clip')
ax.fill_between(steps, low_balanced, high_balanced, alpha=0.1, color=healthy_teal)

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Clip fraction', fontsize=9)
ax.set_title('Balanced (healthy)', fontsize=10, fontweight='normal', loc='left')
ax.legend(frameon=False, fontsize=8, loc='upper right')
ax.set_ylim(0, 0.3)

# --- Panel B: High-dominant (watch carefully) ---
ax = axes[1]

high_dominant = 0.15 + 0.08 * (steps / 500) + np.random.normal(0, 0.015, len(steps))
low_dominant = 0.05 - 0.02 * (steps / 500) + np.random.normal(0, 0.01, len(steps))
high_dominant = np.clip(high_dominant, 0.05, 0.35)
low_dominant = np.clip(low_dominant, 0.01, 0.15)

ax.plot(steps, high_dominant, color=high_clip_colour, linewidth=1, label='High clip')
ax.plot(steps, low_dominant, color=low_clip_colour, linewidth=1, label='Low clip')
ax.fill_between(steps, low_dominant, high_dominant, alpha=0.1, color=high_clip_colour)

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Clip fraction', fontsize=9)
ax.set_title('High-dominant (mode collapse risk)', fontsize=10, fontweight='normal', loc='left')
ax.legend(frameon=False, fontsize=8, loc='upper left')
ax.set_ylim(0, 0.35)
ax.annotate('Policy converging\nstrongly', xy=(400, 0.28), fontsize=8, color=high_clip_colour, ha='center')

# --- Panel C: Low-dominant (unlearning) ---
ax = axes[2]

high_unlearn = 0.06 + np.random.normal(0, 0.01, len(steps))
low_unlearn = 0.08 + 0.1 * (steps / 500) + np.random.normal(0, 0.015, len(steps))
high_unlearn = np.clip(high_unlearn, 0.02, 0.15)
low_unlearn = np.clip(low_unlearn, 0.02, 0.25)

ax.plot(steps, high_unlearn, color=high_clip_colour, linewidth=1, label='High clip')
ax.plot(steps, low_unlearn, color=low_clip_colour, linewidth=1, label='Low clip')
ax.fill_between(steps, high_unlearn, low_unlearn, alpha=0.1, color=low_clip_colour)

ax.set_xlabel('Step', fontsize=9)
ax.set_ylabel('Clip fraction', fontsize=9)
ax.set_title('Low-dominant (unlearning)', fontsize=10, fontweight='normal', loc='left')
ax.legend(frameon=False, fontsize=8, loc='upper left')
ax.set_ylim(0, 0.3)
ax.annotate('Policy abandoning\nprevious preferences', xy=(400, 0.22), fontsize=8, color=low_clip_colour, ha='center')

plt.tight_layout()
plt.savefig('clip_asymmetry.png', dpi=150, bbox_inches='tight', facecolor='white')
plt.show()
```


#### Reward clipping and scaling

Reward clipping operates at a different level entirely. Where ratio clipping constrains *how much the policy can change*, reward clipping constrains *how much any single completion can influence that change*.

::: {.column-margin}
The interaction between reward scaling and advantage normalisation is subtle. When `scale_rewards=True` (the default), rewards are normalised per-group before advantage computation. When `scale_rewards=False`, raw rewards are used, which can lead to very different gradient magnitudes depending on your reward function's scale.
:::

In GRPO, the standard behaviour is to normalise advantages within each group:

$$\hat{A}_i = \frac{r_i - \mu_G}{\sigma_G}$$

where $\mu_G$ and $\sigma_G$ are the mean and standard deviation of rewards within the group. This normalisation is itself a form of "soft" reward scaling -- it makes the absolute magnitude of rewards irrelevant, only their relative ordering within the group matters.

But what happens when $\sigma_G \approx 0$? Division by near-zero creates numerical instability and enormous gradients. TRL handles this by adding a small epsilon to the denominator, but the fundamental problem remains: groups with low reward variance produce unreliable advantage estimates.

**What to watch for:**

- **Reward variance across groups**: If some groups have high variance and others near-zero, your effective batch is smaller than you think. Only the high-variance groups are contributing meaningful gradients.
- **Reward magnitude drift**: If you're using `scale_rewards=False` or have explicit reward clipping, watch for the raw reward distribution shifting over training. A reward function that worked well early may need recalibration as the model improves.
- **Clipped reward fraction**: If you're using explicit reward bounds (e.g., clipping rewards to $[-1, 1]$), track how often clipping is triggered. High clipping rates indicate your reward function's dynamic range exceeds your bounds.


### Instrument 5: entropy dynamics

Policy entropy measures how "spread out" the probability distribution is over possible tokens. High entropy means the model is uncertain; low entropy means it's confident. In GRPO, entropy dynamics are particularly diagnostic because the group-relative objective can push entropy in unintuitive directions.

::: {.column-margin}
TRL logs `entropy` as the mean entropy across tokens and completions. Some implementations also log `entropy_std`, which measures variation in entropy across tokens -- useful for detecting whether the model is uniformly confident or has "confident" and "uncertain" regions.
:::

```{python}
#| eval: false
#| code-fold: true
#| code-summary: "Policy entropy monitoring"
class EntropyCallback(TrainerCallback):
    """Monitor policy entropy for mode collapse detection."""

    def __init__(self, window_size: int = 50, collapse_threshold: float = 1.0):
        self.window_size = window_size
        self.collapse_threshold = collapse_threshold
        self.entropy_history = deque(maxlen=window_size)

    def on_log(self, args, state, control, logs=None, **kwargs):
        if logs is None:
            return

        if "entropy" in logs:
            entropy = logs["entropy"]
            self.entropy_history.append(entropy)

            if len(self.entropy_history) >= 10:
                entropies = list(self.entropy_history)

                # Trend
                logs["entropy/trend"] = np.polyfit(
                    range(len(entropies)), entropies, 1
                )[0]

                # Rate of decline (acceleration)
                if len(entropies) >= 20:
                    first_half = np.mean(entropies[:len(entropies)//2])
                    second_half = np.mean(entropies[len(entropies)//2:])
                    logs["entropy/acceleration"] = second_half - first_half

            # Warning for low entropy
            if entropy < self.collapse_threshold:
                logs["entropy/collapse_warning"] = 1
                print(f"WARNING: Low entropy ({entropy:.3f}). "
                      "Policy may be collapsing to deterministic outputs.")
```

**What to watch for:**

- **Entropy declining too fast**: The model is becoming too confident too quickly. This often precedes mode collapse. Consider adding an entropy bonus to the reward.
- **Entropy not declining at all**: The model isn't learning strong preferences. Check that your reward signal has meaningful variance.
- **Entropy suddenly spiking**: Often indicates the model has "forgotten" what it learned and is reverting to more uncertain behaviour. Check for gradient issues or data anomalies.


### Instrument 6: KL divergence

I covered KL divergence extensively in Part II, but it deserves revisiting in the GRPO context.

::: {.column-margin}
KL divergence is only logged when `beta > 0` in your GRPOConfig. If you're running without a KL penalty (beta = 0), you're flying without this instrument -- which is risky for long training runs.
:::

The KL divergence measures how far your policy has drifted from the reference model. In GRPO, this serves as a crucial stability indicator: even when reward and other metrics look healthy, runaway KL can signal that your model is heading towards reward hacking or capability degradation.

$$D_{\text{KL}}(\pi_\theta \| \pi_{\text{ref}}) = \mathbb{E}_{x \sim \pi_\theta}\left[\log \frac{\pi_\theta(x)}{\pi_{\text{ref}}(x)}\right]$$

The GRPO loss includes a KL penalty term scaled by `beta`:

$$\mathcal{L}_{\text{GRPO}} = \mathcal{L}_{\text{policy}} + \beta \cdot D_{\text{KL}}$$

This penalty pushes the policy back towards the reference, preventing it from drifting too far in pursuit of reward.

**What to watch for:**

- **KL growing steadily without bound**: The policy is drifting further from the reference with each update. If your reward is also increasing, this is classic overoptimisation -- the model is exploiting the reward function rather than genuinely improving. Increase `beta` or reduce learning rate.
- **KL near zero throughout training**: Your `beta` is too high, or the learning rate is too low. The policy is barely moving from the reference. Reduce `beta` to allow more exploration.
- **KL spiking suddenly**: A batch of data caused a large policy shift. Investigate what's different about that batch. This can indicate data quality issues or reward function bugs.
- **KL and reward moving in opposite directions**: If KL increases while reward decreases (or vice versa), the KL penalty may be fighting the reward signal. Consider retuning `beta`.

The relationship between KL and reward is subtle. Some KL increase is expected and healthy -- you *want* the policy to change from the reference, that's the whole point of training. The question is whether the change is productive (aligned with genuine improvement) or pathological (exploiting reward model weaknesses).


## Putting it together: the GRPO dashboard

Based on these instruments, here's my recommended layout for a GRPO monitoring dashboard. This aligns with TRL's documented "crucial values" while incorporating the GRPO-specific insights we've discussed:

**Primary panel (watch constantly):**

1. Reward standard deviation (your main learning signal health indicator)
2. Mean reward (primary objective, but interpret with caution)
3. KL divergence (stability indicator, crucial when beta > 0)

**Secondary panel (check regularly):**

4. Completion length and within-group variance
5. Clip ratios (ratio clipping asymmetry)
6. Entropy (exploration vs exploitation balance)

**Tertiary panel (investigate on anomalies):**

7. Partial reward components (if using composite rewards)
8. Loss (only for detecting numerical issues -- not a progress metric!)
9. Gradient statistics (standard SFT instruments)

```{python}
#| label: fig-grpo-dashboard
#| fig-cap: "A complete GRPO monitoring dashboard: reward std is primary, loss is relegated to anomaly detection."
#| echo: false
#| fig-width: 11
#| fig-height: 10

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec

plt.rcParams.update({
    'font.family': 'serif',
    'font.size': 8,
    'axes.linewidth': 0.5,
    'axes.spines.top': False,
    'axes.spines.right': False,
    'xtick.major.width': 0.5,
    'ytick.major.width': 0.5,
    'xtick.direction': 'out',
    'ytick.direction': 'out',
    'figure.facecolor': 'white',
    'axes.facecolor': 'white',
    'axes.grid': False,
})

np.random.seed(42)
steps = np.arange(0, 500, 1)

fig = plt.figure(figsize=(11, 10))
gs = GridSpec(3, 3, figure=fig, hspace=0.4, wspace=0.35)

# Colours
grey = '#4a4a4a'
light_grey = '#a0a0a0'
healthy_teal = '#2a9d8f'
reward_blue = '#4878a8'
problem_red = '#c44e52'
warning_orange = '#e69f00'
purple = '#7b68a8'

# --- PRIMARY PANEL ---

# 1. Reward std (TOP LEFT - most important)
ax = fig.add_subplot(gs[0, 0])
reward_std = 0.2 * np.exp(-steps / 400) + 0.08 + np.random.normal(0, 0.01, len(steps))
reward_std = np.clip(reward_std, 0.05, 0.35)

ax.plot(steps, reward_std, color=healthy_teal, linewidth=1.2)
ax.axhline(0.05, color=problem_red, linewidth=0.8, linestyle='--', alpha=0.7)
ax.fill_between(steps, 0, reward_std, alpha=0.1, color=healthy_teal)

ax.set_xlabel('Step', fontsize=8)
ax.set_ylabel('Reward std', fontsize=8)
ax.set_title('Reward std (where it\s at)', fontsize=9, fontweight='bold', loc='left', color=healthy_teal)
ax.set_ylim(0, 0.35)
ax.annotate('Danger zone', xy=(450, 0.03), fontsize=7, color=problem_red, ha='right')

# 2. Mean reward (TOP MIDDLE)
ax = fig.add_subplot(gs[0, 1])
mean_reward = 0.3 + 0.5 * (1 - np.exp(-steps / 150)) + np.random.normal(0, 0.03, len(steps))

ax.plot(steps, mean_reward, color=reward_blue, linewidth=1)

ax.set_xlabel('Step', fontsize=8)
ax.set_ylabel('Mean reward', fontsize=8)
ax.set_title('Mean reward (the context)', fontsize=9, fontweight='normal', loc='left')
ax.set_ylim(0, 1.0)

# 3. KL divergence (TOP RIGHT - crucial for stability)
ax = fig.add_subplot(gs[0, 2])
kl = 0.1 * (1 - np.exp(-steps / 80)) + 0.02 * np.log1p(steps / 100)
kl += np.random.normal(0, 0.005, len(steps))
kl = np.clip(kl, 0, 0.3)

ax.plot(steps, kl, color=warning_orange, linewidth=1.2)
ax.axhline(0.2, color=problem_red, linewidth=0.8, linestyle='--', alpha=0.7)
ax.fill_between(steps, 0, kl, alpha=0.1, color=warning_orange)

ax.set_xlabel('Step', fontsize=8)
ax.set_ylabel('KL divergence', fontsize=8)
ax.set_title('KL divergence (stability)', fontsize=9, fontweight='bold', loc='left', color=warning_orange)
ax.set_ylim(0, 0.3)
ax.annotate('Warning threshold', xy=(450, 0.22), fontsize=7, color=problem_red, ha='right')

# --- SECONDARY PANEL ---

# 4. Completion length (MIDDLE LEFT)
ax = fig.add_subplot(gs[1, 0])
mean_length = 150 + 10 * np.sin(steps / 50) + np.random.normal(0, 5, len(steps))
length_std = 35 + np.random.normal(0, 3, len(steps))

ax.plot(steps, mean_length, color=healthy_teal, linewidth=1, label='Mean')
ax.fill_between(steps, mean_length - length_std, mean_length + length_std,
                alpha=0.2, color=healthy_teal, label='Within-group std')

ax.set_xlabel('Step', fontsize=8)
ax.set_ylabel('Length (tokens)', fontsize=8)
ax.set_title('Completion length', fontsize=9, fontweight='normal', loc='left')
ax.legend(frameon=False, fontsize=7, loc='upper right')
ax.set_ylim(50, 250)

# 5. Clip ratios (MIDDLE MIDDLE)
ax = fig.add_subplot(gs[1, 1])
high_clip = 0.1 + 0.02 * np.sin(steps / 35) + np.random.normal(0, 0.01, len(steps))
low_clip = 0.08 + 0.02 * np.sin(steps / 40) + np.random.normal(0, 0.01, len(steps))
high_clip = np.clip(high_clip, 0.03, 0.2)
low_clip = np.clip(low_clip, 0.03, 0.2)

ax.plot(steps, high_clip, color=problem_red, linewidth=0.9, label='High')
ax.plot(steps, low_clip, color=reward_blue, linewidth=0.9, label='Low')
ax.fill_between(steps, low_clip, high_clip, alpha=0.1, color=grey)

ax.set_xlabel('Step', fontsize=8)
ax.set_ylabel('Clip fraction', fontsize=8)
ax.set_title('Clip ratios', fontsize=9, fontweight='normal', loc='left')
ax.legend(frameon=False, fontsize=7, loc='upper right')
ax.set_ylim(0, 0.25)

# 6. Entropy (MIDDLE RIGHT)
ax = fig.add_subplot(gs[1, 2])
entropy = 3.2 - 1.5 * (1 - np.exp(-steps / 200)) + np.random.normal(0, 0.05, len(steps))
entropy = np.clip(entropy, 1.0, 4.0)

ax.plot(steps, entropy, color=purple, linewidth=1)
ax.axhline(1.0, color=problem_red, linewidth=0.8, linestyle='--', alpha=0.7)

ax.set_xlabel('Step', fontsize=8)
ax.set_ylabel('Entropy', fontsize=8)
ax.set_title('Entropy', fontsize=9, fontweight='normal', loc='left')
ax.set_ylim(0, 4.5)
ax.annotate('Danger Will Robinson', xy=(450, 0.8), fontsize=7, color=problem_red, ha='right')

# --- TERTIARY PANEL ---

# 7. Partial rewards (BOTTOM LEFT)
ax = fig.add_subplot(gs[2, 0])
format_r = 0.4 + 0.55 * (1 - np.exp(-steps / 60)) + np.random.normal(0, 0.02, len(steps))
correct_r = 0.25 + 0.45 * (1 - np.exp(-steps / 180)) + np.random.normal(0, 0.03, len(steps))
style_r = 0.4 + 0.15 * (1 - np.exp(-steps / 250)) + np.random.normal(0, 0.04, len(steps))

ax.plot(steps, format_r, color='#2a9d8f', linewidth=0.9, label='Format')
ax.plot(steps, correct_r, color='#4878a8', linewidth=0.9, label='Correctness')
ax.plot(steps, style_r, color='#7b68a8', linewidth=0.9, label='Style')

ax.set_xlabel('Step', fontsize=8)
ax.set_ylabel('Component reward', fontsize=8)
ax.set_title('Partial rewards (maybe)', fontsize=9, fontweight='normal', loc='left', color=light_grey)
ax.legend(frameon=False, fontsize=7, loc='lower right')
ax.set_ylim(0, 1.1)

# 8. Loss (BOTTOM MIDDLE - demoted!)
ax = fig.add_subplot(gs[2, 1])
loss = -0.02 + 0.01 * np.sin(steps / 30) + np.random.normal(0, 0.005, len(steps))

ax.plot(steps, loss, color=light_grey, linewidth=0.9)

ax.set_xlabel('Step', fontsize=8)
ax.set_ylabel('Loss', fontsize=8)
ax.set_title('Loss (meh whatever)', fontsize=9, fontweight='normal', loc='left', color=light_grey)

# 9. Gradient norm (BOTTOM RIGHT) - flat with occasional spikes
ax = fig.add_subplot(gs[2, 2])
# Base: mostly flat around 0.8 with small noise
grad_norm = 0.8 + np.random.normal(0, 0.03, len(steps))
# Add occasional spikes at random locations
spike_indices = [45, 127, 198, 267, 312, 389, 445]
for idx in spike_indices:
    if idx < len(steps):
        spike_height = np.random.uniform(0.4, 0.9)
        grad_norm[idx] += spike_height
        # Quick decay after spike
        for j in range(1, min(5, len(steps) - idx)):
            grad_norm[idx + j] += spike_height * np.exp(-j / 1.5)
grad_norm = np.clip(grad_norm, 0.3, 2.0)

ax.plot(steps, grad_norm, color=light_grey, linewidth=0.9)

ax.set_xlabel('Step', fontsize=8)
ax.set_ylabel('Gradient norm', fontsize=8)
ax.set_title('Gradient norm (I guess, whatevs)', fontsize=9, fontweight='normal', loc='left', color=light_grey)
ax.set_ylim(0, 2.0)

plt.savefig('grpo_dashboard.png', dpi=150, bbox_inches='tight', facecolor='white')
plt.show()
```


## Practical recommendations

Let me close with concrete heuristics for GRPO monitoring:

1. **Set alerts on reward std, not loss.** If reward std drops below 0.05 (or your task-specific threshold), something is wrong. Either saturation, mode collapse, or a bug.

2. **Monitor partial rewards separately.** If using composite rewards, set individual thresholds for each component's variance. A component with zero variance is dead weight.

3. **Watch for length-reward correlation.** If you see completion length systematically trending, investigate whether your reward function has a length bias. Consider adding explicit length penalties or normalisation.

4. **Track clip ratio asymmetry.** Balanced clipping (roughly equal high and low) is healthy. Strong asymmetry indicates the policy is moving decisively in one direction -- which might be good (learning) or bad (collapsing).

5. **Sample completions regularly.** No amount of metrics substitutes for actually reading what the model outputs. Schedule periodic human review of generated completions, especially when metrics show anomalies.

6. **Don't trust the loss.** I've said it before, but it bears repeating. The GRPO loss is not a progress metric. Stop watching it trend. Look at it only for sudden discontinuities that indicate numerical problems.

GRPO represents a significant shift in how we think about policy optimisation, and that shift requires corresponding changes in how we monitor training. The intuitions from supervised learning -- and even from simpler RL methods like PPO -- can actively mislead you here. Build new intuitions around reward variance, completion diversity and clip dynamics, and you'll catch problems that would otherwise only manifest at evaluation time. As in, by which time you've wasted a few tens of thousands of dollars on compute.

---

I hope this has been a useful deep dive into GRPO monitoring! As always, the best way to learn is by doing -- set up these instruments in your own training runs and see what insights you can uncover. Happy training!
